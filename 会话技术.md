# **会话安全性**

## 会话劫持和防御

会话劫持是一种攻击方式，攻击者通过某种手段获取到用户的会话标识（Session ID），然后用这个标识进行恶意操作。常见的方式有：

### 3种类型的会话劫持

- 活跃

攻击者拦截网络中的活动链接时，就会发生活动会话劫持。攻击者将所有与系统的设备链接静音并接管通信通道。关系成功后，服务器与用户系统之间的附属关系被释放。

- 被动

在被动攻击中，黑客监视服务器和客户端之间的信息交换，仅仅读取双方之间的信息交换，以获取可用于恶意目的的相关信息。

- 混合

使用主动和被动方法攻击用户的计算机时发生混合会话劫持。攻击者监控网络流量，直到他们找到系统中的后门，之后攻击者接管会话并模仿合法用户的会话来欺骗安全系统。

### 会话劫持技术

- 跨站脚本

  在跨站点脚本中，攻击者所做的是借助JavaScript捕获受害者的会话ID。首先也是最重要的攻击者将包含恶意JavaScript的链接发送给受害者，如果受害者的选项卡位于链接上，则JavaScript开始运行并完成攻击者的所有指令。除此之外，该指令是由攻击者设置的。

- IP欺骗

  用于从计算机系统获得未经授权的访问，包括IP地址、此IP地址属于受信任的主机。为了执行此技术，攻击者需要客户端的IP地址。之后，攻击者将使用客户端IP地址欺骗数据包添加到TCP绘画中。

- 会话嗅探

  一般使用Wireshark、proxy、OWASP Zed等嗅探器，通过预测会话ID的渗透网络流量。一旦攻击者发现价值，令牌就会被用于未经授权的访问。

- 可预测的会话令牌ID

  会话ID是使用按顺序运行的标准脚本算法那生成的。一个会话ID记录在特定日期，另一个会话ID记录在未来日期，所以可以轻松才出两个日期之间处理了多少会话。这个过程需要准确地猜测会话令牌，较弱的令牌会更容易找到和预测。攻击者通常会捕获多个ID并解码模式以找到有效的会话ID。会话劫持可以缓解，但是很难防止。

- 浏览器中的人攻击

  这种劫持方法中，目标是用户的计算机。木马程序存储在用户的计算机上，并跟踪通过计算机记录的会话，浏览器中的人可以修改任何交易信息并将信息所需的数据输入到目标站点。

- 会话侧顶

  使用数据包嗅探来监控用户的网络流量，在用户在网络浏览器上输入和登录凭据后，拦截会话cookie。攻击者可以劫持会话并访问用户的安全数据。

- 会话固定攻击

  用户尝试访问Web应用程序时，有效的会话ID会成为目标。用户的身份验证在进行中，而攻击者通过虚假身份验证欺骗用户并负责会话，这样，攻击者就可以访问受害者的计算机。会话固定是通过从各种来源识别会话ID进入用户的计算机的最常见方式，例如在URL参数中找到会话ID，隐藏在表单中，保存在cookie中，调用此数据斌用于访问Web应用程序。

- 恶意软件注入

  指专门的恶意软件用于入侵用户的计算机，这些程序旨在窃取浏览器的cookie并在不让用户知道系统的情况下采取行动。该恶意软件通常放置在未经授权的网站上。当用户惦记现场的广告或应用程序时，恶意软件会下载到用户的系统上。

  有权访问本地存储系统的黑客可以轻松窃取会话密钥。他们讲拥有你的计算机访问权限，这将作为访问浏览器临时文件或cookie的窗口。黑客可以执行快速扫描以从服务器或用户的计算机中获取内容。

### 会话劫持攻击的级别

- 传输层劫持

  传输层劫持主要用于TCP链接的多层安全系统，通过拦截网络服务器与用户之间的共享数据，阻止通信通道设置安全连接。

  如果服务器无法识别真包和假包的区别，攻击者可以访问用户的会话。一旦获得访问权限，攻击者就会将作为合法信息覆盖的恶意数据包发送到客户端和服务器。

- 应用层劫持

  一旦用户成功验证了会话ID，攻击者就会从系统中窃取会话ID。应用层劫持也称为中间人攻击，劫持者拦截服务器和客户端之间的通信。

  代理攻击也被认为是应用层劫持，攻击者使用预定义的会话ID嗅探进入代理服务器的直接流量。

### 如何防止会话劫持

- HTTPS安全协议

  确保使用SSL/TLS加密的服务器和用户计算机之间的数据交换，即使攻击者设法获取数据包，他们也无法解密信息以确保你的数据安全。

- 仅HTTP

  HTTPOnly安全方法可防止客户端cookie存储。攻击者无法在服务器部属XSS攻击，从而阻止在浏览器中注入JavaScript。

- 杀毒软件

  防病毒软件检测到对设计的恶意操作并立即阻止该条目。病毒或恶意软件一经识别就会立即删除。使您的操作系统保持最新，以避免系统漏洞。

## 跨站脚本攻击（XSS）和防御

指攻击者在Web页面中插入恶意JavaScript代码（也可能包含html代码），当用户浏览网页时，嵌入其中Web里面的JavaScript代码会被执行，从而达到恶意攻击用户的目的。XSS攻击的是客户端，最终受害者是用户。

XSS漏洞通常是通过PHP输出函数将JavaScript代码输出到html页面中，通过用户本地浏览器执行，所以XSS漏洞关键就是寻找参数未过滤的输出函数。

### XSS的类型

- 反射型XSS/不持久型XSS

  最常见的类型的XSS，漏洞产生的原因是攻击者注入的数据反映在响应中。一个典型的非持久型XSS抱哈一个带XSS攻击向量的链接，即每次攻击需要用户点击。

- 存储型XSS/持久型XSS

  一般发生在XSS攻击向量（一般指XSS攻击代码）存储在网站数据库，当一个页面被用户打开的时候执行。每当用户打开浏览器，脚本执行。持久型XSS相比非持久型XSS攻击危害性更大，用户每当打开页面，查看内容时脚本将自动执行。

- 基于DOM的XSS

  基于文档对象模型的一种漏洞。客户端脚本可以通过DOM动态地修改页面内容，他不依赖于提交数据到服务器，而是从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认就会产生DOM型XSS漏洞。

### 防御

- 标签过滤
- 事件过滤
- 敏感字符过滤 
- 设置HTTPOnly防止Cookie被获取
- 内容安全策略（CSP）
- 在将不可信数据插入到HTML标签之间时，对这些数据进行HTML Entity编码
- 在将不可信数据插入到HTML属性里时，对这些数据进行HTML属性编码
- 在将不可信数据插入到SCRIPT里时，对这些数据进行SCRIPT编码
- 在将不可信数据插入到Style属性里时，对这些数据进行CSS编码

## 跨站请求伪造（CSRF）和防御

### 跨站请求伪造

- 基本概念

  跨站请求伪造是一种攻击，它强制浏览器客户端用户在当前对其进行身份验证后的Web应用程序上执行非本意操作的攻击，攻击的重点在于更改状态的请求，而不是盗取数据，因为攻击者无法查看伪造请求的响应。

- 关键点

  - 受害者没有退出登录，受害者保持身份认证。
  - CSRF继承了受害者的身份和特权，代表受害者执行非本意的、恶意的操作。
  - CSRF会借用浏览器中与站点关联的所有身份凭据，例如用户的会话Cookie，IP地址，Windows域凭据等。

- 目标

  CSRF的目标是更改用户账户的状态，攻击者利用CSRF发送的请求都是更改状态的请求，比如转账，更改密码，购买商品等。

  CSRF场景中，攻击者无法获得服务器的响应。

攻击者可以利用XSS触发CSRF攻击，因为可以利用JS发送HTTP请求。

### 防御

- 无效防御

  使用秘密的Cookie：将存储在浏览器端用来身份认证的cookie信息进行加密。

  仅接收post请求。

  多步交易：可能会被攻击者预测。

  URL重写：用户的身份信息会暴露在URL中，不建议通过引入另一个漏洞来解决当前漏洞。

  HTTPS：所有安全机制前提。

- 有效防御

  验证Referer字段：

  - 前一个URL的上一个URL
  - 添加Token验证
  - 二次验证：在关键操作前再输入密码或验证码
  - HttpOnly：cookie的安全机制，某些情况下禁止JS脚本访问Cookie信息

# **分布式会话管理**

## 分布式环境下的会话同步问题

### 常见的会话同步问题

- 数据一致性：

  由于不同的服务器处理用户的请求，如何保证会话数据的一致性成为难题。如用户在A服务器登录，但请求会在B处理，如果B服务器无法获取用户的会话数据，用户将被迫重新登录。

- 性能问题：

  在同步会话数据时，需要在多个服务器之间频繁传输数据，这可能会增加系统延迟，降低性能。

- 会话粘性：

  将同一用户的所有请求都路由到同一服务器上，但这会导致负载不均衡，无法充分利用所有服务器的资源。

### 解决方案

- 共享存储：

  将会话数据存储在集中式存储中，如数据库和缓存系统。所有服务器都可以访问这个存储系统，从而实现会话和共享的同步。Redis作为分布式缓存解决方案，能够支持高并发的读取和写入，适合存储会话信息。

- Session复制：

  在会话数据发生变化时，自动将会话复制到其他服务器。这种方案确保每个服务器都能获得最新的会话信息，但会带来额外的网络和存储开销。

- Token机制：

  使用Token代替会话数据，Token中可包含用户的状态信息，客户端每次请求时，携带Token，服务器通过验证Token来恢复用户状态。这种方式减少了服务器对会话存储的依赖，但安全性要求较高。

## Session集群解决方案

### 会话粘性(Sticky Session)

通过将同一个用户的请求始终路由到同一台服务器来避免跨服务器的会话同步问题。这通常由负载均衡器（如Nginx）完成，确保每个用户的请求总是发送到处理器初始请求的服务器。这种方式实现简单，无需会话同步，但如果某台服务器出现故障，会话信息将丢失。同时这种方法不利于负载均衡，可能导致单个服务器负载过重。

### Session复制

Session复制指的是当用户会话在某台服务器上更新时，会自动将其复制到集群中所有其他服务器上。这样，即使用户的请求被路由到不同服务器，也可以读取最新的会话消息。用户在不同服务器之间切换时不会丢失会话，但随着服务器数量增加，会话复制的网络开销显著增大，影响系统性能。

### 集中式会话存储

将会话数据存储在集中式存储系统中，例如数据库或分布式缓存。所有服务器都可以访问这一集中存储，从而保证会话数据的共享。服务器之间不需要进行会话同步，简化了管理，且容易扩展，但如果集中式存储的性能不足或出现故障，会影响系统的可用性，因此需要高可用的存储系统。

### 无状态会话

通过使用Token将会话数据存储在客户端，每次请求时客户端携带Token，服务器通过验证Token来回复用户会话信息。这种方式将会话管理从服务器转移到客户端，减少了服务器的会话管理负担。无需维护服务器端的会话状态，适合分布式架构和无状态服务，但Token的大小会增加网络传输量，且如果Token没有妥善管理，可能会存安全风险。



## 使用Redis等缓存技术实现分布式会话

### Redis存储会话的基本原理

Redis是一种高性能的内存数据存储，它支持键值对结构，非常适合会话数据的存储。每当用户在应用程序中创建或更新会话时，服务器会将会话信息存储到Redis中。后续来自同一用户的请求，无论由哪台服务器处理，都可以从Redis中获取会话信息，实现会话的共享。

### 流程

1. 用户请求时，应用服务器检查Redis中是否存在对应的会话ID。
2. 如果会话存在，服务器从Redis加载会话数据。
3. 如果会话不存在或过期，服务器创建新的会话，并将其存储在Redis中。

### 优点

- 高性能：Redis运行在内存中，读取和写入速度极快，适合高并发访问的场景。

- 支持持久化：Redis可以选择将数据持久化到磁盘，防止数据丢失。

- 支持集群模式：通过Redis集群模式，可以实现高可用性和负载均衡，确保在大规模分布式系统中会话数据的高效存取。

### 实现步骤

使用Redis作为分布式会话存储，可以通过以下几步实现：

1. 安装Redis：首先，在服务器上安装Redis，配置好主从复制或集群模式，以实现高可用。
2. 配置会话存储：在应用程序中配置Redis作为会话存储，使用Redis客户端（如`redis-py`、`Jedis`等）与Redis通信。大多数Web框架（如Spring、Express等）都提供了内置的Redis会话存储支持。
3. 设置会话过期时间：Redis支持设置会话的过期时间，防止会话数据长期占用内存。

### 安全性和优化

- 安全性：为了防止会话劫持，可以使用Redis的安全认证机制，并结合`SSL`加密通信。
- 数据压缩：为了节省内存，Redis可以对会话数据进行压缩存储。
- 分布式锁：如果多个服务器可能同时访问同一会话数据，可以使用Redis的分布式锁来避免数据竞争。

### 常见场景

Redis适合处理高并发的Web应用，如电商网站、社交网络等，这类系统需要在多台服务器间共享用户会话数据，同时要求低延迟和高可用性。通过使用Redis，可以确保即使用户的请求在不同服务器之间切换，系统仍然能快速读取其会话状态。

# **会话状态的序列化和反序列化**

## 会话状态的序列化和反序列化

- 序列化：序列化是将对象转换为字节流或其他可存储和传输的格式的过程。通过序列化，会话数据可以被存储在外部系统（如Redis、数据库）中，或在不同服务器之间传递。
- 反序列化：反序列化是将字节流恢复为原始对象的过程。当用户再次访问应用时，服务器通过反序列化会话数据来恢复用户的会话状态。

## 为什么需要序列化会话状态

- 分布式存储：在分布式系统中，会话数据需要在多个服务器之间共享或存储于外部系统（如Redis或数据库）。序列化可以将复杂的对象结构转化为简单的格式，以便在不同系统之间传输或存储。

- 持久化存储：对于需要持久化存储会话数据的应用，序列化能够将会话数据保存到持久化存储中，确保即使服务器重启或崩溃，用户会话仍能恢复。

## Java对象序列化

在Java中，序列化是通过实现`Serializable`接口实现的。Java内置的序列化机制能够将对象及其状态序列化为字节流，并将其存储或传输。反序列化则是将字节流重新转化为Java对象。
在会话管理中，Java的内置序列化可以直接用于将会话状态序列化并存储到文件、数据库或缓存中。

## 自定义序列化策略

默认的Java序列化在性能和效率上可能不满足复杂应用的需求，因此可以通过自定义序列化策略优化会话管理。开发者可以实现`Externalizable`接口，来自定义对象的序列化和反序列化过程，控制哪些数据需要序列化，哪些数据可以忽略，提升性能和效率。

### 自定义策略的优点

- 减少不必要的数据传输，降低网络负担。
- 优化存储格式，减少会话数据占用的内存或存储空间。
- 提高序列化和反序列化的速度。